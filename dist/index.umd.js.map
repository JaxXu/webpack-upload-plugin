{"version":3,"file":"index.umd.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../util/io.mjs","../util/regexp.mjs","../util/status.mjs","../util/static.mjs","../util/log.mjs","../util/util.mjs","../index.mjs"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = (function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tvalue = Promise.resolve(value);\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn Promise.resolve(value).then(_empty);\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar reject = _settle.bind(null, pact, 2);\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n","import fs from 'fs'\n// read file\nexport const read = location => fs.readFileSync(location, 'utf-8')\n// write file\nexport const write = location => content => fs.writeFileSync(location, content)\n","export const getPublicPathExp = () => /__webpack_require__\\.p\\s?=\\s?([^;]+);/g\nexport const getScriptRegExp = () =>\n  /__webpack_require__\\.p\\s?\\+[^[]+\\[(\\S+)][^\\n]+?\\.js['\"];?/g\nexport const getCssChunksRegExp = () => /var\\scssChunks\\s*=\\s*([^;\\n]+);/\nexport const getCssHrefRegExp = () => /var\\shref\\s*=[^\\n]+?chunkId[^\\n;]+;/\n","import fs from 'fs'\nimport path from 'path'\nexport function isFile(input) {\n  return fs.statSync(input).isFile()\n}\n\nexport function isDir(input) {\n  return fs.statSync(input).isDirectory()\n}\n\nexport function isType(type) {\n  return function enterFile(file) {\n    return isFile(file) && path.extname(file) === '.' + type\n  }\n}\n","export const name = 'webpack-upload-plugin'\n","import { name as pjName } from './static.mjs'\n\n/**\n * log information\n * @param {*} msg\n */\nexport function log(msg) {\n  console.log(`[${pjName}]: ${msg}`)\n}\n\n/**\n * log error\n * @param msg\n */\nexport function logErr(msg) {\n  console.error(`[${pjName}]: ${msg}`)\n}\n","import path from 'path'\nimport fs from 'fs'\nimport fse from 'fs-extra'\nimport { read, write } from './io.mjs'\nimport {\n  getCssChunksRegExp,\n  getCssHrefRegExp,\n  getScriptRegExp,\n  getPublicPathExp\n} from './regexp.mjs'\nimport { isFile, isDir, isType } from './status.mjs'\nimport { logErr } from './log.mjs'\nimport { name as pjName } from './static.mjs'\n\nconst DEFAULT_SEP = '/'\nconst FILTER_OUT_DIR = ['.idea', '.vscode', '.gitignore', 'node_modules']\n\n// 1. gather html file\n// 2. gather production file\n// 3. upload all production file\n// 4. find the usage of production file in html file\n// 5. if found, replace\n\n// type related\nconst imgTypeArr = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'ico']\nconst fontTypeArr = ['woff', 'woff2', 'ttf', 'oft', 'svg', 'eot']\nconst isCss = isType('css')\nconst isJs = isType('js')\nconst isOneOfType = (types = ['']) => file =>\n  types.some(type => isType(type)(file))\n\nfunction isFont(path) {\n  return fontTypeArr.some(type => isType(type)(path))\n}\n\nfunction isImg(path) {\n  return imgTypeArr.some(type => isType(type)(path))\n}\n\n/**\n *\n * @param {string[]} input\n * @return {string}\n */\nfunction resolve(...input) {\n  return path.resolve(...input)\n}\n\n/**\n * @param {string} input\n * @param {string=} [sep=DEFAULT_SEP]\n * @return {string}\n */\nfunction normalize(input, sep = DEFAULT_SEP) {\n  const _input = path.normalize(input)\n  return _input.split(path.sep).join(sep)\n}\n\n/**\n * @param {string} input\n * @return {boolean}\n */\nfunction isFilterOutDir(input) {\n  return FILTER_OUT_DIR.includes(input)\n}\n\n/**\n * remove publicPath from webpack config\n * @param {string} publicPath\n * @return {function(string): string}\n */\nconst handlePublicPath = publicPath => content => {\n  // match strictly\n  const regStr = publicPath\n    .split(DEFAULT_SEP)\n    .filter(item => !!item)\n    .map(part => {\n      if (/\\./.test(part)) {\n        return part.replace(/\\.+/g, match =>\n          match\n            .split('')\n            .map(dot => '\\\\' + dot)\n            .join('')\n        )\n      }\n      return part\n    })\n    .join('\\\\/')\n  const refinedRegStr = `([(=]['\"]?)${regStr}`\n  const reg = new RegExp(refinedRegStr, 'g')\n  return content.replace(reg, (_, prefix) => (prefix ? prefix : ''))\n}\n\n/**\n * given localPath, return string to form matching RegExp\n * @param {string} localPath\n * @returns {string}\n */\nfunction generateLocalPathStr(localPath) {\n  const pathArr = localPath.split(DEFAULT_SEP)\n  const len = pathArr.length\n  return pathArr\n    .map((part, index) => {\n      if (index === len - 1) {\n        return `${part}`\n      } else {\n        return `\\\\.?(${part})?`\n      }\n    })\n    .join(`\\\\${DEFAULT_SEP}?`)\n}\n\n/**\n * produce RegExp to match local path\n * @param {string} localPath\n * @return {RegExp}\n */\nfunction generateLocalPathReg(localPath) {\n  const content = generateLocalPathStr(localPath)\n  const prefix = `([(=+]\\\\s*['\"]?)`\n  // using prefix to strictly match resource reference\n  // like src=\"\", url(\"\"), a = \"\"\n  return new RegExp(`${prefix}${content}`, 'g')\n}\n\n/**\n * find file usage\n * 1. make sure the range: srcPath\n * 2. provide inline path to search and to replace with: localCdnPair\n * @param {string} srcPath\n * @param {string=} distPath\n * @param {function=} replaceFn\n * @param {boolean=} [copyWhenUntouched=true] copy file even if the content remains the same\n * @return {function}\n */\nfunction simpleReplace(\n  srcPath,\n  distPath = srcPath,\n  replaceFn = input => input,\n  copyWhenUntouched = true\n) {\n  const srcFile = read(srcPath)\n  return function savePair(localCdnPair) {\n    const ret = localCdnPair.reduce((last, file) => {\n      const localPath = normalize(file[0])\n      const cdnPath = file[1]\n      const localPathReg = generateLocalPathReg(localPath)\n      last = replaceFn(last, srcPath).replace(\n        localPathReg,\n        (_, prefix) => `${prefix}${cdnPath}`\n      )\n      return last\n    }, srcFile)\n    // no such path > force copy > content change\n    const toCopy =\n      !fs.existsSync(distPath) || copyWhenUntouched || ret !== srcFile\n    if (toCopy) {\n      fse.ensureFileSync(distPath)\n      write(distPath)(ret)\n    }\n  }\n}\n\n/**\n * gather specific file type within directory provided\n * 1. provide range to search: src\n * 2. provide the type of file to search: type\n * @param {string} src: directory to search\n * @return {function}\n */\nfunction gatherFileIn(src) {\n  return function gatherFileType(type) {\n    return fs.readdirSync(src).reduce((last, file) => {\n      const filePath = resolve(src, file)\n      if (isFile(filePath)) {\n        path.extname(file) === `.${type}` && last.push(normalize(filePath))\n      } else if (isFilterOutDir(file)) {\n        // do nothing\n      } else if (isDir(filePath)) {\n        last = last.concat(gatherFileIn(filePath)(type))\n      }\n      return last\n    }, [])\n  }\n}\n\n/**\n * make sure urlCb is applied for all cdn results\n * @param {function(string): string} cb\n * @return {function(string[]|{[string]:string}):[string, string][]}\n */\nconst handleCdnRes = cb => entries => {\n  if (typeof cb !== 'function') return logErr(`urlCb is not function`)\n  const isArr = Array.isArray(entries)\n  // if not array, handle as {[localLocation]: [cdnUrl]}\n  const target = isArr ? entries : Object.entries(entries)\n  return target.map(pair => {\n    // pair[1] should be cdn url\n    // pass local path as well\n    pair[1] = cb(pair[1], pair[0])\n    if (typeof pair[1] !== 'string')\n      logErr(`the return result of urlCb is not string`)\n    return pair\n  })\n}\n\n/**\n * given file path, src root and dist root, return file path in dist root\n * @param {string} srcFilePath\n * @param {string} srcRoot\n * @param {string} distRoot\n * @return {string}\n */\nfunction mapSrcToDist(srcFilePath, srcRoot, distRoot) {\n  return srcFilePath.replace(srcRoot, distRoot)\n}\n\n/**\n * generate {id: name} object for all chunk chunk\n * @param {{id: string, name:string,renderedHash: string, contentHash: string}[]} chunks\n * @param {string} chunkFileName\n */\nfunction gatherChunks(chunks, chunkFileName) {\n  return chunks.reduce((last, chunk) => {\n    if (/\\[hash(:\\d+)?]/.test(chunkFileName)) {\n      throw new Error(\n        `[${pjName}]: Do NOT use [hash] as output filename! Use [chunkhash] or [contenthash] instead`\n      )\n    }\n    const { id, name, renderedHash, contentHash } = chunk\n    // handle slice properly\n    const handleLen = source => (match, len) => {\n      if (len) {\n        return source.slice(0, +len.slice(1))\n      }\n      return match\n    }\n    const handleChunkHash = handleLen(renderedHash)\n    // handle webpack@4 as well as <4\n    const handleContentHash = handleLen(\n      contentHash ? contentHash.javascript : renderedHash\n    )\n    last[id] = chunkFileName\n      .replace(/\\[name]/g, name || `${id}`)\n      .replace(/\\[id]/g, `${id}`)\n      .replace(/\\[chunkhash(:\\d+)?]/g, handleChunkHash)\n      .replace(/\\[contenthash(:\\d+)?]/g, handleContentHash)\n    return last\n  }, {})\n}\n\n/**\n * whether chunk is \"entry\" (common chunks is also considered as \"entry\")\n * @param {string} js\n * @returns {boolean}\n */\nfunction isEntryChunk(js) {\n  const content = read(js)\n  return getScriptRegExp().test(content)\n}\n\n/**\n * convert object to array\n * @param {object} obj\n * @returns {*[]}\n */\nfunction getObjValueArray(obj) {\n  return Object.values(obj)\n}\n\n/**\n * update script.src property for request for dynamic import\n * experimental\n * @param {string[]} files\n * @param {{id: string}} chunkCdnMap\n */\nfunction updateScriptSrc(files, chunkCdnMap) {\n  // if no new map was formed, then keep the way it is\n  const len = Object.keys(chunkCdnMap).length\n  if (!len) return\n  files.forEach(file => {\n    const content = read(file)\n    let newContent = content\n    // update chunkMap\n    if (getScriptRegExp().test(content)) {\n      newContent = newContent.replace(getScriptRegExp(), (match, id) => {\n        if (!id) {\n          return match\n        }\n        return `${JSON.stringify(chunkCdnMap)}[${id}];`\n      })\n    }\n    // update publicPath\n    if (getPublicPathExp().test(content)) {\n      newContent = newContent.replace(\n        getPublicPathExp(),\n        `__webpack_require__.p = \"\";`\n      )\n    }\n    write(file)(newContent)\n  })\n}\n\n/**\n * Handle async CSS files extracted by mini-css-extract-plugin\n * @param {string[]} files\n * @param {[string, string][]} cssMap\n */\nfunction updateCssLoad(files, cssMap) {\n  const keys = cssMap.map(([local]) => local)\n  files.forEach(file => {\n    const content = read(file)\n    let newContent = content\n    const match = content.match(getCssChunksRegExp())\n    if (match) {\n      const [, map] = match\n      newContent = newContent.replace(getCssHrefRegExp(), hrefMatch => {\n        // get the new cssMap with {chunkId, href} structure\n        // where chunkId is the id for the css file, and href is the cdn url\n        const fnBody = `\n            const map = ${map};\n            return Object.keys(map).map(chunkId => {\n              ${hrefMatch};\n              href = href.replace(/^\\\\./, \"\");\n              return {chunkId, href};\n            })\n          `\n        const hrefArr = new Function(fnBody)()\n        // convert to {[chunkId]: href} structure\n        const cssChunkIdCdnMap = hrefArr.reduce((last, { chunkId, href }) => {\n          const localIndex = keys.findIndex(key => key.indexOf(href) > -1)\n          if (localIndex < 0) {\n            return last\n          }\n          last[chunkId] = cssMap[localIndex][1]\n          return last\n        }, {})\n        // cannot form new Map, return the original one\n        if (!Object.keys(cssChunkIdCdnMap).length) {\n          return hrefMatch\n        }\n        const newCssMap = JSON.stringify(cssChunkIdCdnMap)\n        return `var href = ${newCssMap}[chunkId];`\n      })\n      // update js entry file with new cssMap\n      write(file)(newContent)\n    }\n  })\n}\n\n/**\n * get id of chunk given a absolute path of chunk file and id:chunk map\n * @param {string} chunkAbsPath\n * @param {{id: string}} chunkMap\n * @returns {string|number}\n */\nfunction getIdForChunk(chunkAbsPath, chunkMap) {\n  return Object.keys(chunkMap).find(\n    key => chunkAbsPath.indexOf(chunkMap[key]) > -1\n  )\n}\n\n/**\n * make assets object to array with local path\n * @param {{[string]: {existsAt: string}}} asset\n * @returns {string[]}\n */\nfunction getExistsAtFromAsset(asset) {\n  return Object.keys(asset).map(name => {\n    const info = asset[name]\n    return info.existsAt\n  })\n}\n\nexport {\n  resolve,\n  simpleReplace,\n  handlePublicPath,\n  updateScriptSrc,\n  updateCssLoad,\n  isEntryChunk,\n  getIdForChunk,\n  gatherChunks,\n  getObjValueArray,\n  handleCdnRes,\n  mapSrcToDist,\n  gatherFileIn,\n  isJs,\n  isCss,\n  isImg,\n  isFont,\n  isOneOfType,\n  imgTypeArr,\n  fontTypeArr,\n  getExistsAtFromAsset\n}\n","import path from 'path'\nimport {\n  parallel,\n  compatCache,\n  beforeUpload as beforeProcess\n} from 'y-upload-utils'\nimport {\n  resolve,\n  simpleReplace,\n  handlePublicPath,\n  getExistsAtFromAsset,\n  handleCdnRes,\n  isCss,\n  isEntryChunk,\n  isFont,\n  isImg,\n  isJs,\n  isOneOfType,\n  imgTypeArr,\n  fontTypeArr,\n  gatherChunks,\n  gatherFileIn,\n  getIdForChunk,\n  mapSrcToDist,\n  getObjValueArray,\n  updateCssLoad,\n  updateScriptSrc\n} from './util/util.mjs'\nimport { log, logErr } from './util/log.mjs'\n\n/**\n * @typedef {function(string): string} urlCb\n */\n\n/**\n * webpack upload plugin\n * early version need more work\n * @param {{upload: Promise}} cdn\n * custom cdn module, need to have an upload API, return a Promise with structured response\n * like {localPath: cdnPath}\n * @param {object} option\n * @param {string=} option.src\n * @param {string=} option.dist\n * @param {(function(string, string=) => string)=} option.urlCb\n * @param {function=} option.onFinish\n * @param {(function(string, string=) => string)=} option.replaceFn\n * @param {(function(string, string) => string)=} option.beforeUpload\n * @param {(string|string[])=} option.staticDir\n * @param {(function() => Promise<*>)=} option.waitFor\n * @param {boolean=} [option.dirtyCheck=false]\n * @param {boolean=} option.logLocalFiles\n * @param {object=} option.passToCdn\n * @param {boolean=} [option.enableCache=false]\n * @param {string=} option.cacheLocation\n * @param {number=} [option.sliceLimit=10]\n * @param {boolean=} option.forceCopyTemplate\n * @param {boolean=} [option.asyncCSS=false]\n * @param {boolean=} [option.smartAssMode=false]\n * @constructor\n */\nfunction UploadPlugin(cdn, option = {}) {\n  this.cdn = cdn\n  this.option = option\n}\n\nUploadPlugin.prototype.apply = function(compiler) {\n  const self = this\n  const {\n    urlCb = input => input,\n    resolve: resolveList = ['html'],\n    src = '',\n    dist = src,\n    onFinish = () => {},\n    onError = () => {},\n    logLocalFiles: logLocal = false,\n    staticDir = '',\n    replaceFn = input => input,\n    beforeUpload,\n    waitFor = () => Promise.resolve(true),\n    dirtyCheck = false,\n    passToCdn,\n    enableCache = false,\n    cacheLocation,\n    sliceLimit,\n    forceCopyTemplate,\n    asyncCSS = false,\n    smartAssMode = false\n  } = this.option\n  // get absolute path of src and dist directory\n  let srcRoot = resolve(src)\n  let distRoot = resolve(dist)\n  let staticDirMut = staticDir\n  let srcMut = src\n  const getLocal2CdnObj = handleCdnRes(urlCb)\n  const isTemplate = isOneOfType(resolveList)\n\n  /**\n   * update chunkMap to {[id: string|number]: cdnUrl}\n   * @param {{[localPath: string]: string}} chunkPairs\n   * @param {{[id: string|number]: string}} chunkMap\n   * @param {*} start\n   */\n  function generateChunkMapToCDN(chunkPairs, chunkMap, start = {}) {\n    return getLocal2CdnObj(chunkPairs).reduce((last, [localPath, cdnPath]) => {\n      const id = getIdForChunk(localPath, chunkMap)\n      last[id] = cdnPath\n      return last\n    }, start)\n  }\n\n  // wrap a new cdn object\n  const rawCdn = {\n    upload(files) {\n      return self.cdn.upload(files, passToCdn)\n    }\n  }\n\n  // log error for cache setup\n  if (!enableCache && cacheLocation) {\n    logErr(`'cacheLocation' provided while haven't set 'enableCache' to true`)\n    logErr(`This won't enable cache`)\n  }\n\n  // wrap with parallel\n  const paralleledCdn = parallel(rawCdn, { sliceLimit })\n\n  // wrap with cache\n  const wrappedCdn = enableCache\n    ? compatCache(paralleledCdn, {\n        passToCdn,\n        cacheLocation\n      })\n    : paralleledCdn\n\n  // wrap with beforeProcess\n  // use beforeUpload properly\n  const cdn = beforeProcess(wrappedCdn, beforeUpload)\n\n  compiler.plugin('done', async function(stats) {\n    try {\n      // wait to handle extra logic\n      await waitFor()\n      const { chunks, options } = stats.compilation\n      const {\n        output: { publicPath = '', path: outputPath },\n        mode\n      } = options\n      // early warning\n      if (mode && mode !== 'none') {\n        log(\"WARNING! Set the mode to 'none' to make it works!\")\n      }\n      if (publicPath) {\n        log(\n          'WARNING! publicPath is not empty, the plugin will try to handle it for you. But it is preferred to toggle it by yourself!'\n        )\n      }\n      // try to be smart ass\n      // which means assume all needed files is in the output.path from webpack\n      if (smartAssMode) {\n        srcRoot = outputPath\n        distRoot = outputPath\n        staticDirMut = outputPath\n        srcMut = outputPath\n      }\n      // don't want to use publicPath since about to use cdn url\n      const removePublicPath = handlePublicPath(publicPath)\n      // actual replaceFn that gonna be used\n      const refinedReplaceFn = (content, location) => {\n        const type = path.extname(location)\n        // only remove publicPath occurrence for css/template files\n        // it's tricky to handle js files\n        const removePublicPathTypes = ['.css', ...resolveList.map(t => `.${t}`)]\n        const toRemove = removePublicPathTypes.includes(type)\n        return replaceFn(\n          toRemove ? removePublicPath(content) : content,\n          location\n        )\n      }\n      // if user offers staticDir\n      // then only collect files from staticDir\n      // instead of ones provided by webpack\n      // if pass in an array, gather files recursively\n      const gatherManualAssets = Array.isArray(staticDirMut)\n        ? type => {\n            return staticDirMut.reduce((last, dir) => {\n              return [...last, ...gatherFileIn(dir)(type)]\n            }, [])\n          }\n        : gatherFileIn(staticDirMut)\n      const manualAssets = staticDirMut\n        ? [...imgTypeArr, ...fontTypeArr, 'css', 'js', ...resolveList].reduce(\n            (last, type) => {\n              const files = gatherManualAssets(type)\n              return files.reduce((fileLast, file) => {\n                return Object.assign(fileLast, {\n                  [file]: {\n                    existsAt: file\n                  }\n                })\n              }, last)\n            },\n            {}\n          )\n        : {}\n      // here we get chunks needs to be dealt with\n      const chunkMap = gatherChunks(chunks, options.output.chunkFilename)\n      // all assets including js/css/img\n      const { assets } = staticDirMut\n        ? { assets: manualAssets }\n        : stats.compilation\n      const assetsNames = Object.keys(assets)\n      // classify assets\n      const desireAssets = assetsNames.reduce(\n        (last, name) => {\n          const assetInfo = assets[name]\n          const location = assetInfo.existsAt\n          if (isImg(location)) {\n            last.img[name] = assetInfo\n          } else if (isCss(location)) {\n            last.css[name] = assetInfo\n          } else if (isJs(location)) {\n            last.js[name] = assetInfo\n          } else if (isFont(location)) {\n            last.font[name] = assetInfo\n          } else if (isTemplate(location)) {\n            last.html[name] = assetInfo\n          }\n          return last\n        },\n        {\n          img: {},\n          css: {},\n          js: {},\n          font: {},\n          html: {}\n        }\n      )\n\n      const { img, css, js, font, html } = desireAssets\n\n      // warning if no template found but staticDirMut set\n      if (staticDirMut && !Object.keys(html).length && !src) {\n        log('WARNING!')\n        log(\n          \"staticDir is set but haven't found any template files in those directories\"\n        )\n        log('Try to use src filed to include your template files')\n      }\n\n      const imgArr = getExistsAtFromAsset(img)\n      const fontArr = getExistsAtFromAsset(font)\n      const jsArr = getExistsAtFromAsset(js)\n      const cssArr = getExistsAtFromAsset(css)\n      const htmlArr = getExistsAtFromAsset(html)\n      const chunkArr = getObjValueArray(chunkMap)\n      const commonChunksArr = jsArr.filter(isEntryChunk)\n\n      // find out which js files are chunk chunk, common chunk, or entry\n      const { notChunkJsArr, chunkArrWAbs, commonChunksWAbs } = jsArr.reduce(\n        (last, js) => {\n          const isCommonChunk = commonChunksArr.some(\n            chunk => js.indexOf(chunk) > -1\n          )\n          const isChunk =\n            !isCommonChunk && chunkArr.some(chunk => js.indexOf(chunk) > -1)\n          if (isCommonChunk) {\n            last.commonChunksWAbs.push(js)\n          } else if (isChunk) {\n            last.chunkArrWAbs.push(js)\n          } else {\n            last.notChunkJsArr.push(js)\n          }\n          return last\n        },\n        {\n          notChunkJsArr: [],\n          chunkArrWAbs: [],\n          commonChunksWAbs: []\n        }\n      )\n\n      if (notChunkJsArr.length) {\n        // nothing\n      }\n\n      // upload img/font\n      // find img/font in css\n      // replace css\n      // now css ref to img/font with cdn path\n      // meanwhile upload chunk files to save time\n      log('uploading img and font...')\n      logLocal && console.log([...imgArr, ...fontArr])\n      const imgAndFontPairs = await cdn.upload([...imgArr, ...fontArr])\n      // update img/font reference in css/js files\n      // including chunk files\n      log('update css/js files with new img and font...')\n      const needToUpdateFiles = [...jsArr, ...cssArr]\n      needToUpdateFiles.forEach(location =>\n        simpleReplace(location, location, refinedReplaceFn)(\n          getLocal2CdnObj(imgAndFontPairs)\n        )\n      )\n      // upload chunk files\n      log('uploading chunks...')\n      logLocal && console.log(chunkArrWAbs)\n      const chunkPairs = await cdn.upload(chunkArrWAbs)\n      // update chunkMap, so far no cdn url for common chunks\n      let newChunkMap = generateChunkMapToCDN(chunkPairs, chunkMap, {})\n      log('uploading css...')\n      logLocal && console.log(cssArr)\n      const cssLocal2CdnObj = await cdn.upload(cssArr)\n      if (asyncCSS) {\n        updateCssLoad(commonChunksWAbs, getLocal2CdnObj(cssLocal2CdnObj))\n      }\n      // entry chunk is just entry file : )\n      // the reason uploading common as well as entry is to support webpack@4 and < 4\n      // have common/entry chunks, update chunkMap within it\n      // upload them, so their cdn url can be added to newChunkMap\n      // then entries can be updated with newChunkMap that has cdn url for common chunks\n      let commonChunksPair = {}\n      if (commonChunksWAbs.length) {\n        updateScriptSrc(commonChunksWAbs, newChunkMap)\n        log('upload common/entry chunks...')\n        commonChunksPair = await cdn.upload(commonChunksWAbs)\n        newChunkMap = generateChunkMapToCDN(\n          commonChunksPair,\n          chunkMap,\n          newChunkMap\n        )\n      }\n      // if use dirty check, then check all js files for chunkMap\n      // since webpack@4, every js is chunk\n      // so only filter out common/entry chunks since they should be updated\n      // and uploaded right above\n      const manifestList = dirtyCheck\n        ? jsArr\n        : jsArr.filter(js => !commonChunksWAbs.includes(js))\n      updateScriptSrc(manifestList, newChunkMap)\n\n      // only js here\n      const adjustedFiles = [...manifestList]\n      // if provide with src\n      // then use it\n      // or use emitted html files\n      const tplFiles = !srcMut\n        ? htmlArr\n        : resolveList.reduce((last, type) => {\n            const findFileInRoot = gatherFileIn(srcMut)\n            last = last.concat(findFileInRoot(type))\n            return last\n          }, [])\n\n      log('uploading js...')\n      logLocal && console.log(adjustedFiles)\n      const jsLocal2CdnObj = await cdn.upload(adjustedFiles)\n      // reuse image/common chunks result here\n      // ! important to reuse common chunks since they could just by entry files\n      const allLocal2CdnObj = Object.assign(\n        jsLocal2CdnObj,\n        cssLocal2CdnObj,\n        imgAndFontPairs,\n        commonChunksPair\n      )\n      tplFiles.forEach(filePath => {\n        simpleReplace(\n          filePath,\n          mapSrcToDist(filePath, srcRoot, distRoot),\n          refinedReplaceFn,\n          forceCopyTemplate\n        )(getLocal2CdnObj(allLocal2CdnObj))\n      })\n      // run onFinish if it is a valid function\n      onFinish()\n      log('all done')\n    } catch (e) {\n      log('err occurred!')\n      console.log(e)\n      // run when encounter error\n      onError(e)\n    }\n  })\n}\n\nmodule.exports = UploadPlugin\n"],"names":["const","read","location","fs","readFileSync","write","content","writeFileSync","getPublicPathExp","getScriptRegExp","getCssChunksRegExp","getCssHrefRegExp","isFile","input","statSync","isDir","isDirectory","isType","type","enterFile","file","path","extname","name","log","msg","console","pjName","logErr","error","DEFAULT_SEP","FILTER_OUT_DIR","imgTypeArr","fontTypeArr","isCss","isJs","isOneOfType","types","some","isFont","isImg","resolve","normalize","sep","_input","split","join","isFilterOutDir","includes","handlePublicPath","publicPath","regStr","filter","item","map","part","test","replace","match","dot","refinedRegStr","reg","RegExp","_","prefix","generateLocalPathStr","localPath","pathArr","len","length","index","generateLocalPathReg","simpleReplace","srcPath","distPath","replaceFn","copyWhenUntouched","srcFile","savePair","localCdnPair","ret","reduce","last","cdnPath","localPathReg","toCopy","existsSync","fse","ensureFileSync","gatherFileIn","src","gatherFileType","readdirSync","filePath","push","concat","handleCdnRes","cb","entries","isArr","Array","isArray","target","Object","pair","mapSrcToDist","srcFilePath","srcRoot","distRoot","gatherChunks","chunks","chunkFileName","chunk","Error","renderedHash","contentHash","handleLen","source","slice","handleChunkHash","handleContentHash","javascript","id","isEntryChunk","js","getObjValueArray","obj","values","updateScriptSrc","files","chunkCdnMap","keys","forEach","newContent","JSON","stringify","updateCssLoad","cssMap","local","hrefMatch","fnBody","hrefArr","Function","cssChunkIdCdnMap","href","localIndex","findIndex","key","indexOf","chunkId","newCssMap","getIdForChunk","chunkAbsPath","chunkMap","find","getExistsAtFromAsset","asset","info","existsAt","UploadPlugin","cdn","option","prototype","apply","compiler","self","beforeUpload","Promise","passToCdn","cacheLocation","sliceLimit","forceCopyTemplate","dist","staticDirMut","staticDir","srcMut","getLocal2CdnObj","urlCb","isTemplate","resolveList","generateChunkMapToCDN","chunkPairs","start","rawCdn","upload","enableCache","paralleledCdn","parallel","wrappedCdn","compatCache","beforeProcess","plugin","stats","waitFor","compilation","options","outputPath","mode","smartAssMode","removePublicPath","refinedReplaceFn","removePublicPathTypes","t","toRemove","gatherManualAssets","dir","manualAssets","fileLast","assign","output","chunkFilename","assets","assetsNames","desireAssets","assetInfo","img","css","font","html","imgArr","fontArr","jsArr","cssArr","htmlArr","chunkArr","commonChunksArr","isCommonChunk","isChunk","commonChunksWAbs","chunkArrWAbs","notChunkJsArr","logLocal","imgAndFontPairs","needToUpdateFiles","newChunkMap","cssLocal2CdnObj","manifestList","dirtyCheck","adjustedFiles","tplFiles","findFileInRoot","jsLocal2CdnObj","allLocal2CdnObj","commonChunksPair","onFinish","asyncCSS","e","onError","module","exports"],"mappings":"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"}